.. _test-functions:

===========================
Test App Services Functions
===========================

This page describes some strategies you can use to test your Atlas App Services Functions code.
As App Services Functions are written in JavaScript, you can use standard JavaScript testing
frameworks and methods to unit test the functions locally.

Due to some unique aspects and limitations of the the App Services Functions
JavaScript runtime, there are some additional considerations that you should take
into account when testing App Services Functions. This page covers how to handle
the uniqueness of App Services Functions.

.. important:: Integration test all App Services Functions

   You should perform integration tests on all App Services Functions before deploying
   them to production environments. Because the App Services runtime differs from
   the standard Node.js runtime, you should test Functions deployed to Atlas App Services
   before using them in a production environment.

   For more information on the unique aspects of the App Services Functions JavaScript runtime,
   refer to:

   - :ref:`Function Constraints <function-constraints>`
   - :ref:`JavaScript Support <js-support>`

Before You Begin
----------------

#. :ref:`Create an App Services App <create-a-realm-app>`
#. :ref:`Configure the CLI to work with your App <realm-cli>`

.. _unit-test-functions:

Unit Test Functions
-------------------

You can write unit tests to validate the functionality of your App Services Functions.
Use any Node.js-compatible testing frameworks to test App Services Functions.
The examples on this page use the `Jest testing framework <https://jestjs.io/>`__.

You must use :wikipedia:`CommonJS modules <CommonJS>` to write unit tests for
App Services Functions.

.. procedure::

   .. step:: Get a local copy of your App Services App

      Pull the latest configuration of your App from the server.

      .. code-block:: sh

         realm-cli pull --remote <App ID>

   .. step:: Create a new Function

      Create a new Function. In the App's configuration files, create a new JavaScript
      file in the ``functions`` directory for your function.

      .. code-block:: sh

         touch functions/hello.js


      You also need to add configuration information for the Function to ``function/config.json``.

      .. code-block:: json

          {
              "name": "hello",
              "private": false,
              "run_as_system": true
          },

      .. seealso::

         For more information on creating a new App Services Function,
         refer to :ref:`Define a Function <define-a-function>`.

   .. step:: Write Function code

      To make your Function code easy to test, you should keep it modular
      by separating its concerns into distinct functions.
      However, you must keep all code for the Function in the file you defined
      in the previous step. You cannot perform relative imports from other files
      in your project. You can also :ref:`import dependencies using npm <external-dependencies>`.

      You must export your function by assigning it to ``export``.

      TODO: literalinclude. caption w filename

      .. code-block:: js

          function greet(word) {
            return "hello " + word;
          }

          function greetWithPunctuation(word, punctuation) {
            return greet(word) + punctuation;
          }

          // Function exported to App Services
          exports = greetWithPunctuation;

   .. step:: Export Function for unit tests

      To use your code to use in separate Node.js unit test files,
      you must use separate CommonJS ``module.exports`` syntax that is not compatible with the
      App Services Functions runtime.

      At the bottom of your Function file, add the ``module.exports`` statement.
      Wrap the statement with a check to see if the global ``module`` object exists.
      You must perform this check because the App Services environment
      does not have the global ``module``.

      TODO: literal include the codeblock w line highlighting. caption w filename

      .. code-block::

          function greet(word) {
            return "hello " + word;
          }

          function greetWithPunctuation(word, punctuation) {
            return greet(word) + punctuation;
          }

          // Function exported to App Services
          exports = greetWithPunctuation;
          // :snippet-end:

          // export locally for use in unit test
          if (typeof module !== "undefined") {
            module.exports = { greet, greetWithPunctuation };
          }

   .. step:: Unit test exported Function code

      Now you can write unit tests for the objects that you exported from the function.
      Create a test file for the Function file.

      .. code-block:: sh

         touch functions/hello.test.js

      TODO: literal include the code block

      .. code-block:: js
         :caption: hello.test.js

          const { greet, greetWithPunctuation } = require("./hello");

          test("should greet", () => {
            const helloWorld = greet("world");
            expect(helloWorld).toBe("hello world");
          });

          test("should greet with punctuation", () => {
            const excitedHelloWorld = greetWithPunctuation("world", "!!!");
            expect(excitedHelloWorld).toBe("hello world!!!");
          });

.. _functions_mock_services:

Create Mocking Services
~~~~~~~~~~~~~~~~~~~~~~~

To write unit tests for Functions that use the :ref:`global context object <function-context>`
or one of the :ref:`other global modules <function-global-modules>`
that App Services Functions expose, you must create mocks of their behavior.

In this example, the Function references an App Services Value via ``context.values.get()``.

TODO: convert to literalinclude and highlight line accessing the value

.. code-block:: js

    function accessAppServicesGlobals() {
      const mongodb = context.services.get("mongodb-atlas");
      const objectId = BSON.ObjectId()

      // ... do stuff with these values
    }

    exports = accessAppServicesGlobals;

    if (typeof module !== "undefined") {
      module.exports = accessAppServicesGlobals;
    }

Attach these mocks to the Node.js global namespace to call them in your
unit tests the way you do in the App Services Functions runtime.

.. code-block:: js

   global.context = {
     // whichever global context methods you want to mock.
     // 'services', 'functions', values, etc.
   }

   // you can also mock other Functions global modules
   global.BSON = {
     // mock methods
   }

You may also want to declare and remove these mocks in setup and teardown blocks
so that they do not pollute the global namespace.

.. code-block:: js

    // adds context mock to global namespace before each test
    beforeEach(() => {
      global.context = {
        // your mocking services
      };
    });

    // removes context from global namespace after each test
    afterEach(() => {
      delete global.context;
    });

    test("should perform operation using App Services globals", () => {
      // test function that uses context
    });

.. example:: Mocking a Function that accesses ``context``

   The hello beautiful world stuff 
