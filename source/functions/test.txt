.. _test-functions:

===========================
Test App Services Functions
===========================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

This page describes some strategies you can use to test your Atlas App Services Functions code.
As App Services Functions are written in JavaScript, you can use standard JavaScript testing
frameworks and methods to unit test the functions locally.

Due to some aspects and limitations of the the App Services Functions
JavaScript runtime, there are some unique considerations that you should take
into account when testing App Services Functions. This page covers how to handle
the uniqueness of App Services Functions.

.. TODO: add back in when documenting integration tests
.. .. important:: Integration test all App Services Functions

..    You should perform integration tests on all App Services Functions before deploying
..    them to production environments. Because the App Services runtime differs from
..    the standard Node.js runtime, you should test Functions deployed to Atlas App Services
..    before using them in a production environment.

..    For more information on the unique aspects of the App Services Functions JavaScript runtime,
..    refer to:

..    - :ref:`Function Constraints <function-constraints>`
..    - :ref:`JavaScript Support <js-support>`

Before You Begin
----------------

#. :ref:`Create an App Services App <create-a-realm-app>`
#. :ref:`Configure the CLI to work with your App <realm-cli>` or
   :ref:`automate deployment with Github <deploy-github>`

.. _unit-test-functions:

Unit Test Functions
-------------------

You can write unit tests to validate the functionality of your App Services Functions.
Use any Node.js-compatible testing frameworks to test App Services Functions.
The examples on this page use the `Jest testing framework <https://jestjs.io/>`__.

You must use :wikipedia:`CommonJS modules <CommonJS>` to write unit tests for
App Services Functions.

.. procedure::

   .. step:: Get a local copy of your App Services App

      .. tabs::

         .. tab:: {+cli+}
            :tabid: cli

            Pull the latest configuration of your App from the server.

            .. code-block:: sh

              realm-cli pull --remote <App ID>

         .. tab:: Github
            :tabid: github

            Pull the latest configuration of your App from Github.

            .. code-block:: sh

              git pull <Remote Name> <Branch name>


   .. step:: Create a new Function

      Create a new Function. In the App's configuration files, create a new JavaScript
      file in the ``functions`` directory for your function.

      .. code-block:: sh

         touch functions/hello.js


      You also need to add configuration information for the Function to ``function/config.json``.

      .. code-block:: json

          {
              "name": "hello",
              "private": false,
              "run_as_system": true
          },

      .. seealso::

         For more information on creating a new App Services Function,
         refer to :ref:`Define a Function <define-a-function>`.

   .. step:: Write Function code

      To make your Function code easy to test, you should keep it modular
      by separating its concerns into distinct functions.
      However, you must keep all code for the Function in the file you defined
      in the previous step. You cannot perform relative imports from other files
      in your project. You can also :ref:`import dependencies using npm <external-dependencies>`.

      You must export your function by assigning it to ``export``.

      .. literalinclude:: /examples/generated/functions/hello.snippet.function.js
         :caption: hello.js

   .. step:: Export Function for unit tests

      To use your code to use in separate Node.js unit test files,
      you must use separate CommonJS ``module.exports`` syntax that is not compatible with the
      App Services Functions runtime.

      At the bottom of your Function file, add the ``module.exports`` statement.
      Wrap the statement with a check to see if the global ``module`` object exists.
      You must perform this check because the App Services environment
      does not have the global ``module``.

      .. literalinclude:: /examples/generated/functions/hello.snippet.function-with-local-export.js
         :caption: hello.js
         :emphasize-lines: 12-15

   .. step:: Unit test exported Function code

      Now you can write unit tests for the objects that you exported from the function.
      Create a test file for the Function file.

      .. code-block:: sh

         touch functions/hello.test.js

      Import the functions to test and add unit tests.

      .. literalinclude:: /examples/generated/functions/hello.test.snippet.greeting-test.js
         :caption: hello.test.js

.. _functions_mock_services:

Create Mocking Services
~~~~~~~~~~~~~~~~~~~~~~~

To write unit tests for Functions that use the :ref:`global context object <function-context>`
or one of the :ref:`other global modules <function-global-modules>`
that App Services Functions expose, you must create mocks of their behavior.

In this example, the Function references an App Services Value via ``context.values.get()``.

.. code-block:: js
   :emphasize-lines: 2-3

    function accessAppServicesGlobals() {
      const mongodb = context.services.get("mongodb-atlas");
      const objectId = BSON.ObjectId()

      // ... do stuff with these values
    }

    exports = accessAppServicesGlobals;

    if (typeof module !== "undefined") {
      module.exports = accessAppServicesGlobals;
    }

Attach these mocks to the Node.js global namespace to call them in your
unit tests the way you do in the App Services Functions runtime.

.. code-block:: js

   global.context = {
     // whichever global context methods you want to mock.
     // 'services', 'functions', values, etc.
   }

   // you can also mock other Functions global modules
   global.BSON = {
     // mock methods
   }

You may also want to declare and remove these mocks in setup and teardown blocks
so that they do not pollute the global namespace.

.. code-block:: js
   :emphasize-lines: 3-5, 10

    // adds context mock to global namespace before each test
    beforeEach(() => {
      global.context = {
        // your mocking services
      };
    });

    // removes context from global namespace after each test
    afterEach(() => {
      delete global.context;
    });

    test("should perform operation using App Services globals", () => {
      // test function that uses context
    });

.. example:: Mocking a Function that accesses ``context``

   The function in this example accesses a App Services Value and returns it.

   .. literalinclude:: /examples/generated/functions/helloWithValue.snippet.hello-with-context-value.js
      :caption: helloWithValue.js
      :emphasize-lines: 2

   Now create a test file ``helloWithValue.test.js``.
   The test file contains the following:

   - Import the function exported from ``helloWithValue.js``.
   - A mock of ``context.values.get()``. Wrap the mock in set up and tear down blocks
     so that it does not pollute the global namespace.
   - A test of the imported function that uses the mock.

   .. literalinclude:: /examples/generated/functions/helloWithValue.test.snippet.test-with-mocking.js
      :caption: helloWithValue.test.js
