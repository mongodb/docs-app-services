.. _test-functions:

===========================
Test App Services Functions
===========================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

This page describes some strategies you can use to test your Atlas App Services Functions code.
As App Services Functions are written in JavaScript, you can use standard JavaScript testing
frameworks and methods to unit test the functions locally.

Due to some differences between the the App Services Functions
JavaScript and standard Node.js, there are some unique considerations that you should take
into account when testing App Services Functions. This page covers how to handle
the uniqueness of App Services Functions.

.. TODO: add back in when documenting integration tests
.. .. important:: Integration test all App Services Functions

..    You should perform integration tests on all App Services Functions before deploying
..    them to production environments. Because the App Services runtime differs from
..    the standard Node.js runtime, you should test Functions deployed to Atlas App Services
..    before using them in a production environment.

..    For more information on the unique aspects of the App Services Functions JavaScript runtime,
..    refer to:

..    - :ref:`Function Constraints <function-constraints>`
..    - :ref:`JavaScript Support <js-support>`

Before You Begin
----------------

#. :ref:`Create an App Services App <create-a-realm-app>`
#. :ref:`Configure the CLI to work with your App <realm-cli>` or
   :ref:`automate deployment with Github <deploy-github>`

.. _unit-test-functions:

Unit Tests for Functions
------------------------

You can write unit tests to validate the functionality of your App Services Functions.
Use any Node.js-compatible testing frameworks to test App Services Functions.
The examples on this page use the `Jest testing framework <https://jestjs.io/>`__.

You must use :wikipedia:`CommonJS modules <CommonJS>` to write unit tests for
App Services Functions.

.. procedure::

   .. step:: Get a local copy of your App Services App

      .. tabs::

         .. tab:: {+cli+}
            :tabid: cli

            Pull the latest configuration of your App from the server.

            .. code-block:: sh

              realm-cli pull --remote <App ID>

         .. tab:: Github
            :tabid: github

            Pull the latest configuration of your App from Github.

            .. code-block:: sh

              git pull <Remote Name> <Branch name>


   .. step:: Create a new Function

      Create a new Function. In the App's configuration files, create a new JavaScript
      file in the ``functions`` directory for your function.

      .. code-block:: sh

         touch functions/hello.js


      You also need to add configuration information for the Function to ``function/config.json``.

      .. code-block:: json

          {
              "name": "hello",
              "private": false,
              "run_as_system": true
          },

      .. seealso::

         For more information on creating a new App Services Function,
         refer to :ref:`Define a Function <define-a-function>`.

   .. step:: Write Function code

      To make your Function code easy to test, you should keep it modular
      by separating its concerns into distinct components.
      You must keep all logic for the Function in the file you defined
      in the previous step. You cannot perform relative imports from other files
      in your project. You can also :ref:`import dependencies using npm <external-dependencies>`.

      You must export your function by assigning it to ``export``.

      .. literalinclude:: /examples/generated/functions/hello.snippet.function.js
         :language: js
         :caption: hello.js
         :emphasize-lines: 10

   .. step:: Export Function for use in unit tests

      To use your code to use in separate Node.js unit test files,
      you must use separate CommonJS ``module.exports`` syntax.

      However, this syntax is not compatible with the App Services Functions runtime.
      The App Services environment does not have the global ``module``.
      To export modules to your unit tests while keeping the file compatible with 
      App Services Functions, you must wrap the  the ``module.exports`` statement
      with a check to see if the global ``module`` object exists.

      .. literalinclude:: /examples/generated/functions/hello.snippet.function-with-local-export.js
         :language: js
         :caption: hello.js
         :emphasize-lines: 12-15

   .. step:: Unit test exported Function code

      Now you can write unit tests for the modules that you exported from the
      Function file. Create a test file for the Function file.

      .. code-block:: sh

         touch functions/hello.test.js

      Import the modules you exported in the previous step and add unit tests.

      .. literalinclude:: /examples/generated/functions/hello.test.snippet.greeting-test.js
         :language: js
         :caption: hello.test.js

.. _functions_mock_services:

Mock Services
~~~~~~~~~~~~~

To write unit tests for Functions that use the :ref:`global context object <function-context>`
or one of the :ref:`other global modules <function-global-modules>`
that App Services Functions expose, you must create mocks of their behavior.

In this example, the Function references an App Services Value via ``context.values.get()``.

.. code-block:: js
   :caption: accessAppServicesGlobals.js
   :emphasize-lines: 2-3

    function accessAppServicesGlobals() {
      const mongodb = context.services.get("mongodb-atlas");
      const objectId = BSON.ObjectId()

      // ... do stuff with these values
    }

    exports = accessAppServicesGlobals;

    if (typeof module !== "undefined") {
      module.exports = accessAppServicesGlobals;
    }

Attach these mocks to the Node.js global namespace. This lets you call the mocks in your
unit tests the same way you do in the App Services Functions runtime.

.. code-block:: js

   global.context = {
     // whichever global context methods you want to mock.
     // 'services', 'functions', values, etc.
   }

   // you can also mock other Functions global modules
   global.BSON = {
     // mock methods
   }

You may also want to declare and remove these mocks in setup and teardown blocks
so that they do not pollute the global namespace.

.. code-block:: js
   :emphasize-lines: 2-6, 9-11

    // adds context mock to global namespace before each test
    beforeEach(() => {
      global.context = {
        // your mocking services
      };
    });

    // removes context from global namespace after each test
    afterEach(() => {
      delete global.context;
    });

    test("should perform operation using App Services globals", () => {
      // test function that uses context
    });

.. example:: Mocking a Function that accesses ``context``

   The function in this example accesses a App Services Value and returns it.

   .. literalinclude:: /examples/generated/functions/helloWithValue.snippet.hello-with-context-value.js
      :language: js
      :caption: helloWithValue.js
      :emphasize-lines: 2

   Now create a test file ``helloWithValue.test.js``.
   The test file contains the following:

   - Import the function exported from ``helloWithValue.js``.
   - A mock of ``context.values.get()``. Wrap the mock in set up and tear down blocks
     so that it does not pollute the global namespace.
   - A test of the imported function that uses the mock.

   .. literalinclude:: /examples/generated/functions/helloWithValue.test.snippet.test-with-mocking.js
      :language: js
      :caption: helloWithValue.test.js
