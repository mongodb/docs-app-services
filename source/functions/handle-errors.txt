.. _functions-handle-errors:

==========================
Handle Errors in Functions
==========================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

This page explains how to work with errors in Atlas Functions.

.. _functions-basic-error-handling:

Basic Error Handling
--------------------

You can handle Function errors using standard JavaScript error handling techniques
like :mdn:`try...catch statements <Web/JavaScript/Reference/Statements/try...catch>`.

.. code-block:: js

   function willThrowAndHandleError(){
     try {
       throw new Error("This will always happen");
     } catch(err){
       console.error("An error occurred. Error message:" + error.message);
     }
   }

   exports = willThrowAndHandleError;

.. _functions-view-logs:

View Logs
---------

You can view records of all Function executions including which an error prevented
successful execution in :ref:`App Service Logs <logs>`.

Depending on how a Function is invoked, it shows up differently in the logs.
For example, Triggers logs have a different format from
logs for Functions called directly from a Realm client SDK.
For more information, refer to the :ref:`Log entry type documentation <log-entry>`.

.. _functions-retry:

Retry Functions
---------------

Atlas Functions do not have built-in retry behavior.
You can add custom retry behavior. For example, you might want to add
retry behavior if the third-party service that your Function calls has
intermittent connectivity, and you want the Function to re-execute
even if the third-party service is temporarily down.

This section describes the following that you can add retry behavior to your Functions:

- :ref:`Recursively Call Functions in Error Handling Blocks <functions-recursive-call>`
- :ref:`Use Database Triggers to Retry Functions <functions-database-trigger-retry>`

.. _functions-recursive-call:

Recursively Call Function in Error Handling Blocks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One way you can retry functions is to handle operations that might fail by
calling a Function :wikipedia:`recursively <Recursion_(computer_science)>`.

On a high-level, this process includes the following components:

- Execute operations that you want to retry in a ``try`` statement
  and have the Function call itself in a ``catch`` statement.
- So that the execution doesn't happen indefinitely, set a maximum number of retries.
  Every time that the Function fails and enters the ``catch`` statement,
  increment a count of the current number of retries.
  Stop the recursive execution when the Function's current number of retries
  reaches the max number of retries.
- You may also want to `throttle <https://docs.microsoft.com/en-us/azure/architecture/patterns/throttling>`__
  retries to reduce the total number of executions.

The following table describes some advantages and disadvantages
of handling Function retries with recursive call strategy.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Advantages
     - Disadvantages

   * - - All retry logic occurs within one function.
       - Minimal additional code.
     - - All retries must occur within a single Function's max execution time.
       - TODO: more cons?

The following code example demonstrates an implementation of retrying a Function 
by using recursion in error handling blocks.

.. code-block:: js

    // Utility function to suspend execution of current process
    async function sleep(milliseconds) {
    await new Promise((resolve) => setTimeout(resolve, milliseconds));
    }

    // Set global variables to be used by all calls to `mightFail`
    const MAX_RETRIES = 5;
    let currentRetries = 0;
    let errorMessage = "";

    async function mightFail(...inputVars) {
    if (currentRetries === MAX_RETRIES) {
      console.error(`Reached maximum number of retries (${MAX_RETRIES}) without successful execution.`);
      console.error(errorMessage);
      return;
    }
    try {
      // operation that might fail
      await callFlakyExternalService(...inputVars);
    } catch (err) {
      errorMessage = err.message;
      // throttle retries to be at most every 5000 milliseconds
      await sleep(5000);
      currentRetries++;
      mightFail(...inputVars);
    }
    }

    exports = mightFail;

.. _functions-database-trigger-retry:

Use Database Triggers to Retry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also retry Functions by using a handler Function that manages retry attempts
with a :ref:`Database Trigger <database-trigger>` to execute retries
and a MongoDB collection to track previously failed executions.

On a high-level, this process includes the following components:

- **Main Function** that execute the logic you want to retry,
  wrapped in the handler function (see below bullet point).
- **Failed execution tracker collection**, a MongoDB collection
  that tracks failed executions of the main Function.
- **Max retries value**: :ref:`App Services Value <app-value>` containing
  the maximum number of times that the handler function should try to execute
  the the main function.
- **Handler Function** that invokes the main Function and logs when the function fails
  to the failed execution tracker collection.
- **Database Trigger Function** that reruns the handler function whenever
  the handler function adds an error to the failed execution tracker collection.

You can support multiple main functions with one set of a handler Function,
execution tracker collection and Database Trigger Function.

.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Advantages
     - Disadvantages

   * - - Each retry is its own Function execution, with own max execution time
         and resources.
       - TODO: more pros?
     - - Each Function call requires two Function invocations, one for the Function
         itself and one for the retry handler.
       - More complex logic, which can be more difficult to write, debug, and monitor.

.. procedure::

   .. step:: Create an execution retry handler Function

      First, create a handler Function ``handleRetry`` that invokes the main Function.

      ``handleRetry`` accepts the following parameters:

      - ``functionToRetry``: the JavaScript function to retry.
      - ``functionName``:  String. Name of the function you want to retry.
      - ``operationId``: ObjectId. Unique identifier for the main function's
        execution, including retries.
      - ``previousRetries``: Number. How many times the main function
        has previously been tried.
      - ``...args``: Arguments passed to the main function.

      ``handleRetry`` performs the following operations:

      #. Attempts to execute ``functionToRetry`` in a ``try`` statement.
         If the execution is successful, ``handleRetry`` returns the value
         returned by ``functionToRetry``.
      #. If the execution of ``functionToRetry`` in the previous step throws an error,
         the ``catch`` statement handles the error as follows:

         a. Checks if the number of previous retries equals the max retries values.
            If the two numbers are the same, then the function throws an error
            because the max retries has been reached. The function no longer attempts
            to retry.
         #. Build a function execution log entry object to insert into the database.
         #. Get a reference to the failed execution tracker collection.
         #. Insert the function log exection log entry into
            the failed execution tracker collection. This insertion operation
            causes the Database Trigger Function, which you will make in the next step,
            to fire.

      The main function is passed as the argument ``functionToRetry``.
      ``handleRetry`` attempts to execute the main Function.
      If the execution fails, this function attempts to retry the main function.

      .. tabs-realm-admin-interfaces::

         .. tab::
            :tabid: ui

            Navigate to :guilabel:`Functions`. Click the button :guilabel:`Create New Function`.

            In the field :guilabel:`Name`, add ``handleRetry``.

            In the :guilabel:`Function Editor` add the following code,
            then save the Function:

         .. tab::
            :tabid: cli

            Add the following to :file:`functions/config.json`:

            .. code-block:: js
               :caption: functions/config.json

               [
                 {
                   "name": "handleRetry",
                   "private": true
                 }
                 // ...other configuration
               ]

            Create the file for the Function :file:`functions/handleRetry.js`:

            .. code-block:: js
              :caption: functions/handleRetry.js

                async function handleRetry(
                  functionToRetry,
                  functionName,
                  operationId,
                  previousRetries,
                  ...args
                ) {
                try {
                  // Try to execute the main function
                  const response = await functionToRetry(...args);
                  return response;
                } catch (err) {
                  // Evaluates if should retry function again.
                  // If no retry, throws error and stops retrying.
                  const maxRetries = context.values.get("MAX_FUNC_RETRIES");
                  if (previousRetries === maxRetries) {
                    throw new Error(`Maximum number of attempts reached (${maxRetries}) for function '${functionName}': ${err.message}`)
                  }

                  // Build function execution log entry for insertion into database.
                  const logEntry = {
                    operationId,
                    errorMessage: err.message,
                    timestamp: Date.now(),
                    retries: previousRetries + 1,
                    args,
                    functionName,
                  };

                  // Get reference to database collection
                  const executionLog = await context.services
                    .get("mongodb-atlas")
                    .db("experimental")
                    .collection("failed_execution_logs");

                  // Add execution log entry to database
                  executionLog.insertOne(logEntry);
                }
                }

   .. step:: Create retry database trigger

      .. tabs-realm-admin-interfaces::

         .. tab::
            :tabid: ui

            #. Navigate to the :guilabel:`Triggers` in the UI of your App.
            #. Click the :guilabel:`Add a Trigger` button.
            #. Create the Trigger with the following configuration:

               .. list-table::
                  :header-rows: 1
                  :widths: 50 50

                  * - Field
                    - Value

                  * - Name
                    - Name of your choosing (ex: ``retryOperation``)

                  * - Enabled
                    - Yes

                  * - Skip Events on Re-Enable
                    - Yes

                  * - Event Ordering
                    - Yes

                  * - Cluster Name
                    - Name of your choosing (ex: ``mongodb-atlas``)

                  * - Database Name
                    - Name of your choosing (ex: ``logs``)

                  * - Collection Name
                    - Name of your choosing (ex: ``failed_execution_logs``)

                  * - Operation Type
                    - Insert

                  * - Full Document
                    - Yes

                  * - Document Preimage
                    - No

                  * - Select An Event Type
                    - Function

                  * - Function
                    - Click :guilabel:`+ New Function`. Refer to the following information
                      about the contents of the function.

                  * - Advanced Configuration
                    - No advanced configuration necessary.

         .. tab::
            :tabid: cli

            Add configuration for the Database Trigger. For more information,
            refer to the :ref:`Trigger configuration reference <appconfig-triggers>`.

            .. code-block:: json
               :caption: triggers/retryOperation.json

              {
                  "name": "retry",
                  "type": "DATABASE",
                  "config": {
                      "operation_types": [
                          "INSERT"
                      ],
                      "database": "myDatabase",
                      "collection": "failed_execution_logs",
                      "service_name": "mongodb-atlas",
                      "project": {},
                      "full_document": true,
                      "full_document_before_change": false,
                      "unordered": false,
                      "skip_catchup_events": false
                  },
                  "disabled": false,
                  "event_processors": {
                      "FUNCTION": {
                          "config": {
                              "function_name": "retryOperation"
                          }
                      }
                  }

      Now add the code for the Function that the Trigger invokes.

      The function ``retryOperation`` takes as a parameter ``logEntry``, the document that the
      retry handler posted to the failed execution tracker collection.
      Then ``retryOperation`` use :ref:`context.functions.execute() <context-functions>`
      to invoke the main function with information from ``logEntry``.

      .. tabs-realm-admin-interfaces::
         :hidden: true

         .. tab::
            :tabid: ui

            In the field :guilabel:`Function Name`, add ``retryOperationDbTrigger``.

            For the field :guilabel:`Function`, add the following code:

            .. code-block:: js
              :caption: functions/retryOperationDbTrigger.js

              async function retryOperation({ fullDocument: logEntry }) {
                // parse values from log entry posted to database
                const { args, retries, functionName, operationId } = logEntry;
                // Re-execute the main function
                await context.functions.execute( functionName, ...args, operationId, retries);
              }

              exports = retryOperation;

         .. tab::
            :tabid: cli

            Add the Function metadata to :file:`functions/config.json`:

            .. code-block:: js
               :caption: functions/config.json

               [
                  // ...other configuration
                  {
                    "name": "retryOperationDbTrigger",
                    "private": true
                  }
               ]

            Add the following code to the file :file:`functions/retryOperationDbTrigger.js`:

            .. code-block:: js
               :caption: functions/retryOperationDbTrigger.js

               async function retryOperation({ fullDocument: logEntry }) {
                 // parse values from log entry posted to database
                 const { args, retries, functionName, operationId } = logEntry;
                 // Re-execute the main function
                 await context.functions.execute( functionName, ...args, operationId, retries);
               }

               exports = retryOperation;

   .. step:: Write function to retry

      Now that you have the function handler and the retry Database Trigger Function,
      you can write the main function.

      In this example, the Function randomly throws an error when performing addition.
      The JavaScript functions that execute this logic are the following:

      - ``getRandomOneTwoThree()``: Helper function for generating errors
        for the example.
      - ``additionOrFailure()``: Function with the main logic.

      The invocation of ``additionOrFailure()`` wrapped by the retry handler
      occurs in the exported function ``additionWithRetryHandler()``.
      **All** functions that use the retry handler function should resemble this function.

      You must include the correct parameters to make this function work
      with the rest of the retry logic. These parameters are:

      .. list-table::
         :header-rows: 1
         :widths: 50 50

         * - Parameter
           - Description

         * - ``...args``
           - Zero or more parameters to pass to the function with main logic.
             In the case of this example, the two numbers added
             in ``additionOrFailure()``, ``num1`` and ``num2``.

         * - ``operationId``
           - :ref:`BSON.Object.Id<bson-objectid>`. Unique identifier for the Function
             call and retries. Set default value to a ``new BSON.ObjectId()``.

         * - ``retries``
           - Number. Set default value to 0.

      The body of ``additionWithRetryHandler`` is the retry handler ``handleRetry``
      invoked by ``context.functions.execute()``,
      which in turn invokes ``additionOrFailure``. The arguments you pass to
      context.functions.execute() are the following:

      .. list-table::
         :header-rows: 1
         :widths: 50 50

         * - Argument
           - Description

         * - ``"handleRetry"``
           - String. Name of the Function you defined to invoke the main function
             and post to the retry logs if the main function doesn't properly execute.

         * - ``additionOrFailure``
           - JavaScript function. The main function that ``handleRetry()`` invokes.

         * - ``operationId``
           - BSON.ObjectId. Passed in as argument from the parameter ``operationId`` of ``additionWithRetryHandler()``.

         * - ``retries``
           - Number. Passed in as argument from the parameter ``retries`` of ``additionWithRetryHandler()``.

         * - ``...args``
           - Zero or more arguments to pass to the function with main logic.
             Passed in as argument from the parameter ``...args`` of ``additionWithRetryHandler()``


      .. code-block:: js

          // randomly generates 1, 2, or 3
          function getRandomOneTwoThree() {
          return Math.floor(Math.random() * 3) + 1;
          }

          function additionOrFailure(num1, num2) {
            // Throw error if getRandomOneTwoThree returns 1
            const rand = getRandomOneTwoThree();
            if (rand === 1) throw new Error("Uh oh!!");
            const sum = num1 + num2;
            console.log(`Successful addition of ${num1} + ${num2}. Result: ${sum}`)

            // Otherwise return the sum
            return sum;
          }

          async function additionWithRetryHandler(
          inputVar1,
          inputVar2,
          // create a new `operation_id` if one not provided
          operationId = new BSON.ObjectId(),
          // count number of attempts
          retries = 0
          ) {
            const res = await context.functions.execute(
              "handleRetry",
              additionOrFailure,
              "additionWithRetry", // MUST BE NAME OF FUNCTION
              operationId,
              retries,
              inputVar1,
              inputVar2
            );
            return res;
          }

          exports = additionWithRetryHandler;



