.. _flexible-sync-permissions-guide:

===============================
Flexible Sync Permissions Guide
===============================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

This page shows how to set up your flexible sync app's permissions for the
following common use cases:

- :ref:`read-write-own-data`
- :ref:`write-own-data-read-all-data`
- :ref:`admin-privileges`
- :ref:`restricted-news-feed`
- :ref:`dynamic-collaboration` - not currently possible.
- :ref:`tiered-privileges`

These assume you have already created a Realm app.

.. seealso::

   :ref:`create-realm-apps`
   :ref:`flexible-sync-rules-and-permissions`

.. _read-write-own-data:

Read & Write Own Data
---------------------

In this case, users may not read or write any data but their own. Consider a
notes app where the user wants their notes to be persisted and shared across
their own devices but kept private to their user account.

This strategy permits a user to create and edit a document if and only if that
document's ``owner_id`` field equals the user's ID.

To set this up, follow these steps:

.. include:: /includes/use-flex-sync-templates

- :guilabel:`Define Permissions`: use the template dropdown to
  select the template called "Users can only read and write their own data".

  This populates the rule expression box with something like the following:

  .. code-block:: json
     :emphasize-lines: 6-7
  
     {
       "defaultRoles": [
         {
           "name": "owner-read-write", 
           "applyWhen": {},
           "read": {"owner_id": "%%user.id"},
           "write": {"owner_id": "%%user.id"}
         }
       ]  
     }

  Note that the "read" and "write" expressions use the ``owner_id`` field we
  marked as "queryable" above. It also uses the ``%%user`` expansion to read the
  requesting user's id.

  When a client accesses the data through Sync, Realm evaluates these
  expressions to determine permissions. This expression says the requesting user
  may read or write if the document's ``owner_id`` field is equal to the user's
  ID.

- Skip :guilabel:`Advanced Configuration`, and then click :guilabel:`Save Changes` 
  to enable Sync with these permissions.


.. _write-own-data-read-all-data:

Write Own Data, Read All Data
-----------------------------

In this case, users can read all data, but write only their own data. Consider a 
recipe app where users can read all recipes and add new recipes. The recipes 
they add can be viewed by everyone using the app. 

To set this up, follow these steps:

.. include:: /includes/use-flex-sync-templates

- :guilabel:`Define Permissions`: use the template dropdown to
  select the template called "Users can read all data but only write their own data".

  This populates the rule expression box with the following:

  .. code-block:: json
     :emphasize-lines: 6-7
  
     {
        "defaultRoles": [
          {
            "name": "owner-write", 
            "applyWhen": {},
            "read": true,
            "write": {"owner_id": "%%user.id"}
          }    
        ]  
      }

  Note that the "read" expression is set to ``true``, indicating that 
  no matter which user is authenticated, they can access all of the data. 
  The "write" expression uses the ``owner_id`` field we marked as "queryable" 
  above and uses the ``%%user`` expansion to match against the requesting user's 
  id. 

  When a user accesses the data through Sync, Realm evaluates these
  expressions to determine permissions. This expression says the requesting user
  may read all data, but write only if the document's ``owner_id`` field is equal 
  to the user's ID.

- Skip :guilabel:`Advanced Configuration`, and then click :guilabel:`Save Changes` 
  to enable Sync with these permissions.

.. _admin-privileges:

Administrator Privileges
------------------------

In this permission strategy, users with a specific "administrator" role can 
read and write any document. Users who do not have the specified role can only 
read and write their own data. To make this strategy work, you first need to 
define which users have administrator permissions. You do this by enabling 
Custom User Data and defining the document that contains the user data.

In the custom user data document that you define, you create   
a field that is used to indicate whether the user has administrative 
privileges. While there are many ways to set this up, one approach is to add 
a boolean property called ``isAdmin``, which is set to ``true`` for those 
users with the elevated permissions. Another is to create a string field 
called ``role``, in which one of the expected values might be "admin". 

In the following example, the custom user object we have created has 3 fields: 
``firstName``, ``lastName``, and ``isGlobalAdmin``:

.. code-block:: json

   {
      "_id" : "1234",
      "firstName": "Lily",
      "lastName": "Realmster",
      "isGlobalAdmin": true
   }

Configure Custom User Data
~~~~~~~~~~~~~~~~~~~~~~~~~~

{+service+} stores MongoDB documents that correspond to custom user data
in a linked MongoDB Atlas cluster. When you configure custom user data for your 
application, you specify the cluster, database, collection, and finally a 
User ID field, which maps a custom user data document to an 
authenticated user's ID. To enable custom user data, follow these steps:

.. include:: /includes/define-custom-user-data.rst

Set Up Admin Privileges
~~~~~~~~~~~~~~~~~~~~~~~
After you have custom user data enabled, you can implement the Admin Privileges 
strategy. To do so, follow these steps:

.. include:: /includes/use-flex-sync-templates

- :guilabel:`Define Permissions`: use the template dropdown to
  select the template called "Users can read and write their own data, admins 
  can read and write all data".

  This populates the rule expression box with the following:

.. code-block:: json

   {
     "defaultRoles": [
       {
         "name": "admin", 
         "applyWhen": { "%%user.custom_data.isGlobalAdmin": true},
         "read": true,
         "write": true
       },
       {
         "name": "user", 
         "applyWhen": {},
         "read": {"owner_id": "%%user.id"},
         "write": {"owner_id": "%%user.id"}
       }
     ]  
   }

.. note:: Change the default settings

   The generated expression has two objects in the "defaultRoles" 
   array. The first defines the permissions for an administrator. Note that the 
   auto-generated expression assumes there is a boolean field in the custom user 
   data document named ``isGlobalAdmin``. Depending on how you defined your custom 
   user data document, you may need to change this. 
   
   The second section of the "defaultRoles" array defines the rules for all other 
   users. The default is to restrict user access to read and write only their own 
   data. You can change either or both of these fields to ``true``, enabling 
   users to read and/or write all data. See the previous sections to learn more 
   about these strategies.

- Skip :guilabel:`Advanced Configuration`, and then click :guilabel:`Save Changes` 
  to enable Sync with these permissions.


.. _restricted-news-feed:

Restricted News Feed
--------------------

In this permission strategy, users can create their own content and subscribe 
to other creators' content. As with the Admin Privileges scenario, we will 
make use of a Custom User Data collection to define which authors' content 
a user is subscribed to read.

Flexible {+sync-short+} supports querying arrays, so we will create an array 
within a user data object. This array contains IDs of the authors that this user 
is authorized to "follow". We then set up a subscription that says, in essence, 
"Give me all documents where I am the author, or the author's ID is in the array  
of authors in my custom user data."

.. important:: Client Reset Required on Array Change

   When a user subscribes or unsubscribes from an author, we update the array 
   in the custom user data, but the changes don't take effect until the current 
   session is closed and a new session is started.

.. note:: Size Limitations

   In this example, we are creating an array in the Custom User Data. The 
   size of this array is not limited by {+realm+}, but because the data is 
   included in each request, we recommend keeping the size under 16KB, which 
   is enough space for 1000 128-bit GUID-style user IDs.

 
Configure Custom User Data
~~~~~~~~~~~~~~~~~~~~~~~~~~

To enable custom user data, follow these steps:

.. include:: /includes/define-custom-user-data.rst

Create Authentication Trigger Function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We need to create a authentication trigger function that creates a custom user 
object when a user authenticates for the first time. To do so, follow these steps:  

.. include:: /includes/create-auth-trigger.rst

Set Up Restricted Permissions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the custom user data object, create an array that holds the _id values of 
each author the user is following. In this example, we'll call it "subscriptions". 
Our user data object looks like the following, where Lily Realmster 
(``"_id": "1234"``) is subscribed to all documents written by users "456" 
and "789":

.. code-block:: json

   {
      "_id" : "1234",
      "firstName": "Lily",
      "lastName": "Realmster",
      "user.custom_data.subscribedTo": [
        "456",
        "789"
      ]
   }

You can now implement the Restricted Privileges strategy. To do so, follow these 
steps:

.. include:: /includes/use-flex-sync-templates

- :guilabel:`Define Permissions`: use the template dropdown to
  select the template called "Users can only read and write their own data". 
  This populates the rule expression box with the following, which is not 
  *exactly what we want*, but provides most of the logic for us:

  .. code-block:: json

    {
      "defaultRoles": [
        {
          "name": "owner-read-write", 
          "applyWhen": {},
          "read": {"owner_id": "%%user.id"},
          "write": {"owner_id": "%%user.id"}
        }
      ]  
    }

  Note that a user can currently read only their own documents 
  (``"read": {"owner_id": "%%user.id"}``). We need to add an ``$or`` statement to 
  include all documents written by a subscribed author. Those authors' IDs are 
  stored in an array, so we also use the ``$in`` operator. The expression looks 
  like this:

  .. code-block:: json

    {
      "defaultRoles": [
        {
          "name": "owner-write", 
          "applyWhen": {},
          "read": {"$or" : [
              {"owner_id": "%%user.id"},
              {"owner_id": {"$in": [
                "%%user.custom_data.user.custom_data.subscribedTo"
              ]}}
            ]},
          "write": {"owner_id": "%%user.id"}
        }    
      ]
    }

- Update the rule expression box with this new logic and save the changes.

.. _dynamic-collaboration:

Dynamic Collaboration
---------------------

In the Dynamic Collaboration strategy, users can create documents and add other
users as editors of that document.

Like the Read & Write Own Data strategy, this strategy permits a user to create
and edit a document if that document's ``owner_id`` field equals the user's ID.
Additionally, a user may edit the document if the document's ``collaborators``
array field contains their ID.

To implement this strategy, follow these steps:

.. include:: /includes/use-flex-sync-templates

- Also in :guilabel:`Select Queryable Fields`: type in ``collaborators`` as well. This
  will be the field that stores the IDs of users who can also read and write
  the document.
- :guilabel:`Define Permissions`: use the template dropdown to
  select the "Custom (start from scratch)". Paste the following into the rule
  expression box: 

  .. code-block:: json

     {
       "rules": {},
       "defaultRoles": [
         {
           "name": "read-only",
           "applyWhen": {},
           "write": {
             "$or": [
               {
                 "owner_id": "%%user.id"
               },
               {
                 "collaborators": "%%user.id"
               }
             ]
           }
         }
       ]
     }
  
  Take a look at the "write" expression. ``$or`` takes an array of options. We
  have two possible conditions where a user may write the document:
  
  - The ``owner_id`` field of the document equals the user's ID
  - The ``collaborators`` array field of the document contains the user's ID.

  If granted write permission, the user automatically gets read permission.
  Therefore, we omitted the "read" expression as it would be redundant in this
  case.

A user can add a collaborator to their document by adding the collaborator's
user ID to the ``collaborators`` array field on their document. This can be done
on the client side.

How exactly you get the potential collaborator's user ID depends on the details
of your app and your UI. There is no built-in functionality for searching for
users -- you need to set this up according to your app's needs. For example,
your app might use email/password authentication. When a user wants to add a
collaborator to a document, you might have a search box that accepts an email
address. Upon entering an email address, the client calls a Realm backend
function that queries your user data collection. You had set up an
authentication trigger to fire upon user registration. The trigger function
stores each new user's email address and ID in the user data collection. So, if
the email address was found by the search function, the user ID can be returned
to the client. The client can then add the collaborator user ID to the
document's collaborators list.

Caveats
~~~~~~~

If a user has write access to a document, they may write to any field of the
document. Consequently, this strategy **allows collaborators to add
collaborators**. It would also allow a collaborator to edit the ``owner_id``
field. We don't recommend using this model for highly sensitive data.

.. _tiered-privileges:

Tiered Privileges
-----------------

In this permission strategy, we will introduce **roles** as well as rules. Their 
are two roles: **a team member** and **a team administrator**. The rules are as 
follows:

- Each user is a member of a team. 
- A user can read and write their own documents.
- All members of the team can read all documents created by team members. 
- Each team has a team administrator, who has read & write permissions on every 
  team document.

To make this work, we need to do the following:

- Enable custom user data
- Create a trigger function to create a new custom user data object for each 
  new user
- Create a function to add a user to a team
- Define the Sync permissions

Configure Custom User Data
~~~~~~~~~~~~~~~~~~~~~~~~~~

To enable custom user data, follow these steps:

.. include:: /includes/define-custom-user-data.rst

Create Authentication Trigger Function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We need to create a authentication trigger function that creates a custom user 
object when a user authenticates for the first time. To do so, follow these steps:  

.. include:: /includes/create-auth-trigger.rst


Create joinTeam Function
~~~~~~~~~~~~~~~~~~~~~~~~~

We now need a function that adds a user to a team. Note that this function 
will run under System authentication and writes to the custom user data. It 
does not perform an upsert because the user custom data was created when the user 
successfully authenticated for the first time.

To create the function, follow these steps:

- Log in to the Realm UI, and then click :guilabel:`Functions` in the left 
  hand panel.

- Click the :guilabel:`Create New Function` button.

- Specify the following values:

  - :guilabel:`Name`: "joinTeam"
  
  - :guilabel:`Authentication`: "System"
  
- Switch to the :guilabel:`Function Editor` tab and replace the placeholder text 
  with the following code: 

   .. code-block:: json

      exports = async function(userId, teamName) {
      var collection = context.services.get("custom-user-data").db("Item").collection("User");

      const filter = { _id: userId };
      const update = { $set: { team: teamName }};
      const options = { upsert: false };

      let result = await collection.updateOne(filter, update, options);
      return result;
      };


Define Sync Permissions
~~~~~~~~~~~~~~~~~~~~~~~
The following {+sync-short+} permissions specify two roles:

- **teamAdmin** applies only when the user's custom data has 
  ``isTeamAdmin: true``. If so, the user can read and write all documents where 
  the document's ``team`` value matches the user's ``team`` value.
- **teamMember** applies to every user. The user can write their own 
  documents and read all documents where the document's ``team`` value matches 
  the user's ``team`` value.

.. code-block:: json

   {
      "rules": {},
      "defaultRoles": [
      {
         "name": "admin",
         "applyWhen": {
         "%%user.custom_data.isTeamAdmin": true
         },
         "read": {
         "team": "%%user.custom_data.team"
         },
         "write": {
         "team": "%%user.custom_data.team"
         }
      },
      {
         "name": "user",
         "applyWhen": {},
         "read": {
         "team": "%%user.custom_data.team"
         },
         "write": {
         "owner_id": "%%user.id"
         }
      }]
   }


.. note:: Take it Further

   This strategy can be expanded to support a "globalAdmin" role. The global 
   admin would have read & read permissions on any doc created in any team. 

.. seealso:: Authentication Triggers

   :ref:`<authentication-triggers>`.

.. seealso:: Enable Custom User Data

   :ref:`<custom-user-data>`

