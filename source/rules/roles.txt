.. _roles:
.. _permissions:

======================
Role-based Permissions
======================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

You secure your App's data by defining **roles** that are automatically assigned
to incoming user requests or Device Sync sessions. Each role has fine-grained
data access permissions and dynamic conditions that determine when the role
applies.

For examples of how you might configure permissions for common scenarios with
Device Sync, see the :ref:`flexible-sync-permissions-guide`.

If you're using the older Partition-Based Sync Device Sync mode, rules and roles
work differently. To configure Partition-Based Sync permissions, see
:ref:`partition-based-sync-permissions`.

What are Permissions?
~~~~~~~~~~~~~~~~~~~~~

A **permission** is a status that Atlas App Services assigns to individual users
to control what they can and cannot do with your app's data. App Services uses
both document-level and field-level permissions:

- Document-level permissions control whether a user can insert, delete, modify,
  and search for a specific document in a MongoDB collection. These permissions
  always apply to the entire document regardless of the content.

- Field-level permissions control whether a user can read or write the data in
  specific fields of a document. These permissions only affect the field they
  apply to, which means that a user may have read or write access to only a
  subset of the entire document.

What are Roles?
~~~~~~~~~~~~~~~

A **role** is a named set of permissions that a user may have for documents in a
MongoDB collection. A role has an "apply when" :ref:`expression <expressions>`
that determines whether App Services should assign the role to a user. Roles
also have a set of document- and field-level permissions that a user has when
assigned the role.

App Services only commits operations that a user is authorized to do based on
their assigned role. If a role does not have permission to read a document or
some of its fields, App Services omits the document or fields from the results.

.. example::

   Consider a collection named ``employees`` where each employee has their own
   document with all of their employment data. This collection might have two
   roles: **Employee** and **Manager**. We're not using Device Sync, so App
   Services selects a role on a per-document basis.

   - If a user requests their own document, their role is **Employee**. An
     employee can read and write their own data but can't create or delete their
     own documents.

   - If a user requests a document for someone whose name is listed in the
     user's ``manages`` arrays, their role is **Manager**. A manager can read
     and write their direct reports' data and can create and delete their
     documents.

   - If a user is neither an **Employee** nor a **Manager** for a given
     document, then they have no role and cannot read, write, or search that
     document.
   
   .. tabs::
      
      .. tab:: Roles
         :tabid: roles
         
         .. code-block:: json
            
            
            {
              "name": "Manager",
              "apply_when": { "email": "%%user.custom_data.manages" },
              "insert": true,
              "delete": true,
              "read": true,
              "write": true,
              "search": true,
              "fields": {},
              "additional_fields": {
                "read": true,
                "write": true
              }
            }
            {
              "name": "Employee",
              "apply_when": { "email": "%%user.data.email" },
              "insert": false,
              "delete": false,
              "read": true,
              "write": true,
              "search": true,
              "fields": {},
              "additional_fields": {
                "read": true,
                "write": true
              }
            }
      
      .. tab:: Employee Documents
         :tabid: documents
         
         .. code-block:: json
            
            {
              "_id": ObjectId(...),
              "employeeId": "0528",
              "name": "Phylis Lapin",
              "team": "sales",
              "email": "phylis.lapin@dundermifflin.com",
              "manages": []
            }
            {
              "_id": ObjectId(...),
              "employeeId": "0713",
              "name": "Stanley Hudson",
              "team": "sales",
              "email": "stanley.hudson@dundermifflin.com",
              "manages": []
            }
            {
              "_id": ObjectId(...),
              "employeeId": "0865",
              "name": "Andy Bernard",
              "team": "sales",
              "email": "andy.bernard@dundermifflin.com",
              "manages": [
                "phylis.lapin@dundermifflin.com",
                "stanley.hudson@dundermifflin.com"
              ]
            }

Why Define a Role?
~~~~~~~~~~~~~~~~~~

A role carries a specific set of permissions that you might expose to your app's
users. The exact roles and permissions that you define will vary based on your
app's data and requirements. To determine good roles for a collection, consider
your data from the perspective of your app's users and what it might mean to
them.

.. example::
   
   In addition to **Employee** and **Manager** roles, you might add a
   **Teammate** role to the ``employees`` collection to represent a user on the
   same team as the document's employee. Teammates can read each other's data
   but cannot modify it.
   
   .. code-block:: json
      
      {
        "name": "Teammate",
        "apply_when": { "team": "%%user.data.team" },
        "insert": false,
        "delete": false,
        "read": true,
        "write": false,
        "search": true,
        "fields": {},
        "additional_fields": {
          "read": true,
          "write": false
        }
      }

How App Services Assigns Roles
------------------------------

App Services assigns roles differently depending on whether you're using
:ref:`Device Sync (Flexible Mode) <sync>` or not.

When using Device Sync, App Services assigns roles at the start of a Sync
session; otherwise, App Services assigns roles on a per-document basis. A Sync
session starts when opening a sync connection and ends when closing the sync
connection.

You can define a set of roles for a collection and default roles for when the
collection roles don't apply. To assign a role, App Services evaluates each
role's "apply when" expression. The first role whose "apply when" expression
evaluates to true becomes the assigned role.

Role Assignment: Device Sync Disabled
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When not using Device Sync, App Services dynamically assigns roles for every
request. The user is assigned a separate role, or no role, for each document
that matches the incoming query. 

First, your App evaluates and applies :ref:`filters <filters>` and then runs the
query.

.. example::
   
   This request would cause App Services to evaluate a role for every document in the
   ``restaurants`` collection where the ``city`` field is set to ``"Chicago"``:
   
   .. code-block:: javascript
      
      db.restaurants.updateMany(
        { "city": "Chicago" },
        { "$set": { "city": "Chicago, IL" } }
      );

For each document returned by the query, your App evaluates possible
roles in :ref:`role order <role-order>` and assigns the first applicable
role, if any. A role applies to a given document if its Apply When
:ref:`expression <expressions>` evaluates to ``true`` when run against
the document.

The set of roles that a user may play for a given request depends on the
collection they're accessing. If the collection has a set of
collection-level roles defined, then a user may play any of those roles.
If there are no collection-level rules, the request falls back to the
data source's default roles.

.. example::
   
   An employee will always be on their own team, so both the **Employee** and
   **Teammate** roles apply to them for their own document. However, they can
   only one play one role, so we want to use **Employee** because it's more
   specific.
   
   To configure this, specify **Employee** earlier than **Teammate** in the
   collection's role definitions:
   
   .. tabs-realm-admin-interfaces:: 
      
      .. tab::
         :tabid: ui
         
         .. figure:: /images/role-order.png
            :alt: Role definitions that specify Manager first, Employee second, and Teammate third.
      
      .. tab::
         :tabid: cli
         
         .. code-block:: json
            
            {
              "database": "<Database Name>",
              "collection": "<Collection Name>",
              "roles": [
                { "name": "Manager", ... },
                { "name": "Employee", ... },
                { "name": "Teammate", ... }
              ]
            }

Role Assignment: Device Sync Enabled
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When using Device Sync, App Services assigns a role at the beginning of each
Sync session. The role determines which permissions apply for the duration of a
Flexible Sync session.

.. seealso::

   For a guide to setting up Flexible Sync with common permissions
   models, see :ref:`flexible-sync-permissions-guide`.

When a user begins a session by opening a synced realm, roles are evaluated and
applied to the user for each collection to be synced. App Services assigns at
most one role per collection. If no session role applies for a collection, the
user cannot sync (or read or write) any entries in that collection.

A session role stays assigned for the duration of the session. If something
relevant to a user's session roles changes in the middle of the user's session,
the user is **not** assigned an updated role until they start a new session. For
example, if the user's metadata or the role's "apply when" expression changes,
the user continues to use their existing session role until the next time they
start a session.

Define Roles & Permissions
--------------------------

You can configure your app's data access rules from the App Services UI or by
deploying configuration files with {+cli+}:

.. tabs-realm-admin-interfaces::

   .. tab::
      :tabid: ui

      1. Click :guilabel:`Rules` in the left navigation menu and then select a
         collection from the data source's collection list. You can also
         select :guilabel:`Default roles and filters` to configure
         :ref:`default rules <default-rules>` for the entire cluster.
      
         If no roles are defined yet, you'll be prompted to create a new
         one. Otherwise you'll see an ordered list of existing roles.
         
      #. To create a new role, click :guilabel:`Add role`. You can
         either start from scratch or use a preset role as a starting
         point.
         
      #. Give the role a name. The name can be anything you want but
         must be unique within a given collection. Consider using names
         that describe the user (e.g. ``Admin``) and/or their
         relationship to the data (e.g. ``Owner``).
      
      #. Define an :guilabel:`Apply When` expression that determines when
         a given user has the role for a given document.
      
      #. Define :ref:`document filters <document-filters-expressions>` for the
         role.

      #. Define :ref:`document-level permissions <document-level-permissions>`
         for the role.
      
      #. Define :ref:`field-level permissions <field-level-permissions>` for the
         role.
      
      #. Save the role.

      #. If a collection has more than one role assigned, you can modify
         their :ref:`role order <role-order>` by clicking the arrows on
         each role.
     
   .. tab::
      :tabid: cli
      
      1. Pull the latest version of your app.
         
         .. code-block:: bash

            realm-cli pull --remote="<Your App ID>"
      
      2. Define :ref:`roles and filters <config-collection-rules>` for one or
         more collections. You can also define :ref:`default roles and filters
         <config-default-rules>` that apply to any unconfigured collection. See
         :ref:`rule-config` for details.

         .. tabs::

            .. tab:: Collection Rules
               :tabid: collection-rules

               .. code-block:: json
                  :caption: /data_sources/<data source>/<database>/<collection>/rules.json
                  
                  {
                    "database": "<Database Name>",
                    "collection": "<Collection Name>",
                    "roles": [
                      {
                        "name": "<Role Name>",
                        "apply_when": {},
                        "document_filters": {
                          "read": { Expression },
                          "write": { Expression }
                        },
                        "insert": true,
                        "delete": true,
                        "search": true,
                        "fields": {
                          "myField": { "read": true, "write": true }
                        },
                        "additional_fields": { "read": true, "write": true }
                      }
                    ],
                    "filters": [
                      {
                        "name": "<Filter Name>",
                        "apply_when": {},
                        "query": {},
                        "projection": {}
                      }
                    ]
                  }

            .. tab:: Default Rules
               :tabid: default-rules
               
               .. code-block:: json
                  :caption: /data_sources/<data source>/default_rule.json
                  
                  {
                    "roles": [
                      {
                        "name": "<Role Name>",
                        "apply_when": {},
                        "document_filters": {
                          "read": { Expression },
                          "write": { Expression }
                        },
                        "insert": true,
                        "delete": true,
                        "search": true,
                        "fields": {
                          "myField": { "read": true, "write": true }
                        },
                        "additional_fields": { "read": true, "write": true }
                     }
                    ],
                    "filters": [
                      {
                        "name": "<Filter Name>",
                        "apply_when": {},
                        "query": {},
                        "projection": {}
                      }
                    ]
                  }
      
      3. Deploy your app.
         
         .. code-block:: bash
            
            realm-cli push

.. _apply-when-expressions:

Apply When Expressions
~~~~~~~~~~~~~~~~~~~~~~

A role's "apply when" expression is a :ref:`rule expression <expressions>` that
determines whether the role should be assigned.

You can use expression variables to make roles dynamic. For example, you can use the
:json-expansion:`%%user` expansion to refer to the specific user that issued the
request. This lets you customize your data access permissions on a per-user
basis.

When not using Device Sync, you can refer to the current document for which a
role is being assigned. For example, you can use :json-expansion:`%%root`. This
lets you customize your data access permissions on a per-document basis.

.. _document-filters-expressions:

Document Filters
~~~~~~~~~~~~~~~~

The role's ``document_filters`` expressions determine whether the role's
subsequent document- and field-level permissions may be evaluated at all.

.. _document-level-permissions:

Document-Level Permissions
~~~~~~~~~~~~~~~~~~~~~~~~~~

A role's document-level permissions determine which actions that affect
the entire document a user with the role can perform. A role can have
any of the following document-level permissions:

- **Insert**: The role can insert new documents.
- **Delete**: The role can delete existing documents.
- **Search**: The role can find the document in Atlas Search results.

.. _field-level-permissions:

Field-Level Permissions
~~~~~~~~~~~~~~~~~~~~~~~

A role's field-level permissions determine whether or not a user with
the role can read or write individual fields within the document.

You can define field-level permissions for specific fields as well as
default read/write permissions for any additional fields that you don't
explicity define.

.. _role-order:

Role Order
~~~~~~~~~~

The roles for a given collection each have a position that determines
the order in which they are evaluated and applied. Each role's apply
when expression is evaluated in role order until a role applies or no
roles remain.

A user may only have one role per document in a given query. Role order
determines which role applies in the event that multiple roles' "apply when"
expressions are true. Therefore, when defining roles, put the most specific
roles first.

.. _sync-compatible-roles:

Sync-Compatible Roles
~~~~~~~~~~~~~~~~~~~~~

If Device Sync (Flexible Mode) is enabled, an assigned role must be **sync
compatible**. If the role is not sync compatible, but its ``apply_when``
evaluated to true, others roles are not considered; access is denied.

A role is not sync compatible if any of the following conditions are true:

- ``document_filters.read`` or ``document_filters.write`` are undefined.
- A document filter, insert, or delete expression references: a field that is
  not a :ref:`queryable field <queryable-fields>`; an expansion other than
  ``%%true``, ``%%false``, ``%%values``, ``%%environment``, or ``%%user``; or
  the ``%function`` operator.
- Field-level permissions are not boolean literals (``true`` or ``false``).
- Field-level permissions are specified for the top-level ``_id`` field.
