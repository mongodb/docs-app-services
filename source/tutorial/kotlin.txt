.. _kotlin-tutorial:

============================
Android With Kotlin Tutorial
============================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

Realm provides a Kotlin SDK that allows you to create an Android mobile
application with Kotlin using :android:`Jetpack Compose </jetpack/compose/documentation>`. 
This tutorial is based on the Kotlin Flexible Sync
Template App, named ``kotlin.todo.flex``, which illustrates the creation of a
To-do Item List management application. This application enables users to: 

- Register their email as a new user account.
- Sign in to their account with their email and password (and sign out later).
- View, create, modify, and delete their own tasks.
- View all tasks, even where the user is not the owner.

The template app also provides a toggle that simulates the device being in 
"Offline Mode." This toggle lets you quickly test Device Sync functionality 
on the simulator, emulating the user having no internet connection. However,
you would likely remove this toggle in a production application.

This tutorial adds functionality to the Template App. You will add a new ``Priority`` field 
to the existing ``Item`` model and update the 
:ref:`Flexible Sync subscription <queryable-fields>` to only show items within 
a range of priorities. This example illustrates how you might adapt the 
template app for your own needs. You would not necessarily make 
this change given the current structure of the template app. 

Depending on your experience with Kotlin, this tutorial should take 
around 30 minutes.

.. note:: Check Out the Quick Start
   
   If you prefer to get started with your own application rather than follow a 
   guided tutorial, check out the :ref:`Kotlin Quick Start <kotlin-client-quick-start>`. 
   It includes copyable code examples and the essential information that you 
   need to set up an Atlas App Services backend.

Prerequisites
-------------

- :android:`Android Studio <studio/index.html>` Bumblebee 2021.1.1 or higher.
- JDK 11 or higher.
- Kotlin Plugin for Android Studio, version 1.6.10 or higher.
- An Android Virtual Device (AVD) using a supported CPU architecture.

.. include:: /includes/tutorial-template-prerequisite.rst 

Start with the Template
-----------------------
This tutorial is based on the Kotlin SDK Flexible Sync Template App named 
``kotlin.todo.flex``. We start with the default app and build new features 
on it. 

From Realm CLI, you can run the :ref:`realm-cli apps create 
<realm-cli-apps-create>` command to set up the backend and create the 
Kotlin base app. The following command creates a new app based on the 
kotlin.todo.flex template. With the options flags we can pass during creation,
the command below creates an app:

- Named "MyTutorialApp"
- Deployed in the US-VA region
- With the environment set to "development" (instead of production or QA)

.. code-block:: shell

   realm-cli apps create -n MyTutorialApp --template kotlin.todo.flex \
      --deployment-model global --location us-va --environment development

To learn more about the Template Apps and to install the Template App that this
tutorial uses in the Atlas App Services UI, see :ref:`template applications
<template-apps>`. 

Set up the Template App
-----------------------

.. procedure::

   .. step:: Open the App

      Navigate to the directory where the Realm CLI created the Template App. 
      The client code is in a ``frontend/kotlin.todo.flex`` directory.
      Open the ``build.gradle.kts`` file in Android Studio.

   .. step:: Explore the App Structure

      Take a few minutes to explore the project organization while Android
      Studio indexes your project. Within the ``app/java/com.mongodb.app``
      directory, you can see a few files worth noting:

      .. cssclass:: config-table
      .. list-table::
         :header-rows: 1
         :widths: 35 65

         * - File
           - Purpose

         * - ComposeItemActivity.kt
           - Activity class that defines the layout and provides 
             functionality for opening a realm, writing Items to the realm, 
             logging a user out, and closing a realm.

         * - ComposeLoginActivity.kt
           - Activity class that defines the layout and provides 
             functionality for registering a user and logging a user in.

         * - TemplateApp.kt
           - Class that initializes the App Services App. 
           
      In this tutorial, you'll be working in the following files:

      .. cssclass:: config-table
      .. list-table::
         :header-rows: 1
         :widths: 35 65

         * - File
           - Purpose
  
         * - Item.kt
           - Located in the ``domain`` directory. Defines the Realm object we store in the database.

         * - AddItem.kt
           - Located in the ``ui/tasks`` directory. Contains the composable function that 
             defines the layout used when adding an item.

         * - AddItemViewModel.kt
           - Located in the ``presentation/tasks`` directory. The view model that contains 
             business logic and manages state when adding an item.
         
         * - SyncRepository.kt
           - Located in the ``data`` directory. Repository used to access Realm Sync and
             defines the Flexible Sync subscription.

         * - Strings.xml
           - Located in the ``res/values`` directory. Defines the :android:`text string resources <guide/topics/resources/string-resource>`
             used in the app.  
       

   .. step:: Run the App

      Without making any changes to the code, you should be able to
      :android:`run the app <studio/run>`  
      on an Android Emulator using Android Studio or on a physical device.

      When you installed the template app, the Realm CLI also set up a new 
      backend for you and populated the ``realm.xml`` file with the correct app 
      ID. 

      Run the app, register a new user account, and then add a new Item to your 
      todo list.

   .. step:: Check the Backend

      Log in to `Atlas App Services <http://cloud.mongodb.com>`_. In the 
      :guilabel:`Atlas` tab, click on :guilabel:`Browse Collections`. In the list 
      of databases, find and expand the :guilabel:`todo` database, and then the 
      :guilabel:`Item` collection. You should see the document you created 
      in this collection.

Modify the Application
----------------------

.. procedure::

   .. step:: Add a New Property to the Model

      Now that you have confirmed everything is working as expected, we can add 
      changes. In this tutorial, we have decided that we want to add a
      "priority" property to each Item so that we can filter Items by their
      priority level. The priority property will be mapped to a ``PriorityLevel`` enum
      to constrain the possible values, and we will use the ordinal of each 
      enum to correspond to the priority integer so we can query based on a 
      numeric priority level later.
      
      To do this, follow these steps:

      A. Open the ``build.gradle.kts`` file in Android Studio. 

      #. Within the ``app/java/com.mongodb.app/domain`` folder open the ``Item`` class file.
            
      #. Add a PriorityLevel enum above the ``Item`` class:
         
         .. code-block:: kotlin

            enum class PriorityLevel() {
                  Severe, // priority 0
                  High,   // priority 1
                  Medium, // priority 2
                  Low     // priority 3
            }

      #. Add the following property to your Realm Object Schema, before the ``constructor``:

         .. code-block:: kotlin

            var priority: Int = PriorityLevel.Low.ordinal

         This sets the default priority to 3, indicating that it is a low-priority todo item.

   .. step:: Set the Priority when Creating a New Item

      A. From the ``ui/tasks`` folder, open the ``AddItem.kt`` file. This file defines
         the composable functions for the UI that displays when a user clicks 
         the '+' button to add a new todo item. 
      
      #. First, add the following imports below the ``package com.mongodb.app``:
      
         .. code-block:: kotlin

            import androidx.compose.foundation.layout.fillMaxWidth
            import androidx.compose.foundation.layout.padding
            import androidx.compose.material3.*
            import androidx.compose.runtime.*
            import androidx.compose.ui.Modifier
            import androidx.compose.ui.unit.dp
            import com.mongodb.app.domain.PriorityLevel

      #. Now we can add a dropdown field to the ``AddItemPrompt`` composable function
         that will enable the user to pick a priority level 
         from a list using the PriorityLevel enums as available values. 
       
         Before the closing tag of the ``Column``, add the following code for the 
         new dropdown field to the ``ColumnScope``:
   
         .. code-block:: xml

            val priorities = PriorityLevel.values()

            ExposedDropdownMenuBox(
               modifier = Modifier.padding(16.dp),
               expanded = viewModel.expanded.value,
               onExpandedChange = { viewModel.open() },
            ) {
               TextField(
                  readOnly = true,
                  value = viewModel.taskPriority.value.name,
                  onValueChange = {},
                  label = { Text(stringResource(R.string.item_priority)) },
                  trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = viewModel.expanded.value) },
                  colors = ExposedDropdownMenuDefaults.textFieldColors(),
                  modifier = Modifier
                        .fillMaxWidth()
                        .menuAnchor()
               )
               ExposedDropdownMenu(
                  expanded = viewModel.expanded.value,
                  onDismissRequest = { viewModel.close() }
               ) {
                  priorities.forEach {
                        DropdownMenuItem(
                           text = { Text(it.name) },
                           onClick = {
                              viewModel.updateTaskPriority(it)
                              viewModel.close()
                           }
                        )
                  }
               }
            }

         Android Studio will identify several errors. We'll correct these in the next steps 
         by adding the related functions. 
               
      #. Next, we'll define the dropdown field label as a string resource.
         Open the ``res/values/strings.xml`` file, and add the following before 
         the closing of the 'resource' element: 
   
         .. code-block:: xml

            <string name="item_priority">Item Priority</string>

      #. Now within the ``presentation/tasks`` folder, open the ``AddItemViewModel.kt``
         file. Here we will add the business logic related to our new dropdown field.

         First, add the following import below the ``package com.mongodb.app``: 

         .. code-block:: kotlin

            import com.mongodb.app.domain.PriorityLevel
         
         Next, add the following variables to the ``AddItemViewModel`` class to handle the state
         changes within the dropdown:

         .. code-block:: kotlin

            private val _taskPriority: MutableState<PriorityLevel> = mutableStateOf(PriorityLevel.Low)
            val taskPriority: State<PriorityLevel>
               get() = _taskPriority

            private val _expanded: MutableState<Boolean> = mutableStateOf(false)
            val expanded: State<Boolean>
               get() = _expanded

         Then add the following related functions: 

         .. code-block:: kotlin

            fun updateTaskPriority(taskPriority: PriorityLevel) {
               _taskPriority.value = taskPriority
            }

            fun open() {
               _expanded.value = true
            }

            fun close() {
               _expanded.value = false
            }

         Now update the ``addTask()`` and ``cleanUpAndClose()`` functions to include the new
         ``taskPriority`` parameter and update the message to include the priority information:

         .. code-block:: kotlin
            :emphasize-lines: 4, 7

            fun addTask() {
               CoroutineScope(Dispatchers.IO).launch {
                     runCatching {
                        repository.addTask(taskSummary.value, taskPriority.value)
                     }.onSuccess {
                        withContext(Dispatchers.Main) {
                           _addItemEvent.emit(AddItemEvent.Info("Task '$taskSummary' with priority '$taskPriority' added successfully."))
                        }
                     }.onFailure {
                        withContext(Dispatchers.Main) {
                           _addItemEvent.emit(AddItemEvent.Error("There was an error while adding the task '$taskSummary'", it))
                        }
                     }
                     cleanUpAndClose()
               }
            }

         .. code-block:: kotlin
            :emphasize-lines: 3

            private fun cleanUpAndClose() {
               _taskSummary.value = ""
               _taskPriority.value = PriorityLevel.Low
               _addItemPopupVisible.value = false
            }
      
      #. Finally, from the ``data`` folder, open the ``SyncRepository.kt`` file to 
         reflect the same changes in the ``addTask()`` function, which writes the 
         Item to the realm. 

         First, add the following import below the ``package com.mongodb.app``:

         .. code-block:: kotlin

            import com.mongodb.app.domain.PriorityLevel

         Next, update ``addTask()`` to pass the ``taskPriority`` as a parameter: 

         .. code-block:: kotlin

            suspend fun addTask(taskSummary: String, taskPriority: PriorityLevel)

         In the ``RealmSyncRepository`` class, update the ``addTask()`` function to pass 
         ``taskPriority`` as a parameter and write the ``priority`` field to the realm 
         as an integer (using the enum ordinal): 

         .. code-block:: kotlin
            :emphasize-lines: 1, 5

            override suspend fun addTask(taskSummary: String, taskPriority: PriorityLevel) {
               val task = Item().apply {
                     owner_id = currentUser.id
                     summary = taskSummary
                     priority = taskPriority.ordinal
               }
               realm.write {
                     copyToRealm(task)
               }
            }

         Finally, in the ``MockRepository`` class, update the ``addTask()`` function to 
         also pass ``taskPriority`` as a parameter: 

         .. code-block:: kotlin
            
            override suspend fun addTask(taskSummary: String, taskPriority: PriorityLevel) = Unit

   .. step:: Run and Test
    
      At this point, you can rerun the application. Log in using the account 
      you created earlier in this tutorial. You will see the one Item you 
      previously created. Add a new Item, and you will see that you can now 
      set the priority. Choose ``High`` for the priority and save the Item. 

      Now switch back to the Atlas data page in your browser, and refresh the 
      ``Item`` collection. You should now see the new Item with the ``priority`` 
      field added and set to **1**. The existing Item does not have a ``priority`` 
      field.

      .. figure:: /images/swiftui-tutorial-two-new-items.png
         :alt:  Two items in a collection
         :figwidth: 300px

      .. note:: Why Didn't This Break Sync?
      
         Adding a property to a Realm object is not a breaking change and therefore 
         does not require a :ref:`client reset <client-resets>`. The template 
         app has Development Mode enabled, so changes to the client Realm object 
         are reflected in the server-side schema. For more information, see 
         :ref:`<development-mode>` and :ref:`<additive-changes-synced-schema>`.

Change the Subscription
~~~~~~~~~~~~~~~~~~~~~~~

.. procedure:: Change the Subscription

   .. step:: Update the subscription

      Within the ``app/java/com.mongodb.app/data`` folder, open the ``SyncRepository.kt``
      file, where we define the Flexible Sync subscription. The subscription defines
      which documents we sync with the user's device and account. Find the
      ``getQuery()`` function. You can see that
      we are currently subscribing to two subscriptions: 
      
      - ``MINE``: All documents where the ``ownerId`` property matches the authenticated user.
      - ``ALL``: All documents from all users.
      
      We want to update the ``MINE`` subscription to *only* sync Items that are marked as High or Severe priority. 

      As you may recall, the ``priority`` field is of type ``int``, where the highest 
      priority ("Severe") has a value of 0, and the lowest priority ("Low") has 
      a value of 3. We can make direct comparisons between an integer and the 
      priority property. To do so, edit the RQL statement to include documents 
      where the priority is equal to or *less* than PriorityLevel.High (or 1), as 
      shown here:

      .. code-block:: kotlin
         :emphasize-lines: 3

         private fun getQuery(realm: Realm, subscriptionType: SubscriptionType): RealmQuery<Item> =
            when (subscriptionType) {
                  SubscriptionType.MINE -> realm.query("owner_id == $0 AND priority <= ${PriorityLevel.High.ordinal}", currentUser.id)
                  SubscriptionType.ALL -> realm.query()
            }
      
      We'll also force the subscription query to recalculate which documents to 
      sync every time we open the app. 

      To do this, find the ``SyncConfiguration.Builder().initialSubscriptions()`` function 
      that our application calls on start, and add the ``reRunOnOpen`` parameter set to ``true``: 

      .. code-block:: kotlin
         :emphasize-lines: 2

         config = SyncConfiguration.Builder(currentUser, setOf(Item::class))
            .initialSubscriptions(rerunOnOpen = true) { realm ->
                // Subscribe to the active subscriptionType - first time defaults to MINE
                val activeSubscriptionType = getActiveSubscriptionType(realm)
                add(getQuery(realm, activeSubscriptionType), activeSubscriptionType.name)
            }
            .errorHandler { session: SyncSession, error: SyncException ->
                onSyncError.invoke(session, error)
            }
            .waitForInitialRemoteData()
            .build()

   .. step:: Run and Test
    
      Run the application again. Log in using the account you created earlier in
      this tutorial. Here, you'll notice an error if you check your
      :android:`logs using Logcat <studio/debug/am-logcat>`. You will see an
      entry that looks something like this:

      .. code-block:: sh
         :copyable: false
         
         io.realm.kotlin.mongodb.exceptions.BadFlexibleSyncQueryException:
         Client provided query with bad syntax: unsupported query for table
         "Item": key "priority" is not a queryable field

      This message tells us that we have added a field to our subscription
      without configuring Flexible Sync to use that field. 

   .. step:: Update Flexible Sync on the Server

      A. Switch back to the Atlas page in your browser. Select the 
         :guilabel:`Atlas App Services` tab and open the app you are using.

      #. In the left-hand navigation, choose :guilabel:`Device Sync`, and then 
         click **OK** in the dialog box about Development Mode being enabled.
      
      #. Scroll down to the :guilabel:`Select Queryable Fields` section. In the 
         dropdown labeled **Select or create a queryable field**, choose 
         "priority". The priority field will be added to the fields shown:

         .. figure:: /images/dotnet-tutorial-priority-subscribed.png
            :alt:  Priority field is now queryable.

      #. Save your changes.

   .. step:: Test the changes

      Return to your mobile app. To ensure the subscription is re-run, log out 
      the current user and then log in again. 
      After an initial moment when Realm re-syncs the document collection, you 
      will see the new Item of High priority that you created.
      
      If you want to test the functionality further, you can create Items of various 
      priorities. You'll note that if you try to add an Item with a priority lower than High, you will 
      get a Toast message indicating you do not have permission. And if you check your
      :android:`logs using Logcat <studio/debug/am-logcat>`, you will see a message 
      indicating the item was "added successfully", followed by a sync error:      

      .. code-block:: sh
         :copyable: false

         ERROR "Client attempted a write that is outside of permissions or query 
         filters; it has been reverted"   
      
      That's because, in this scenario, Realm creates the Item locally, syncs it with the 
      backend, and then reverts the write because it doesn't meet the 
      subscription rules.

      You'll note, too, that the document you initially created is not synced, 
      because it has a priority of ``null``. If you want this Item to be synced, 
      you can edit the document in the Atlas UI and add a value for the priority 
      field.

Conclusion
----------
Adding a property to an existing Realm object is a non-breaking change, and 
Development Mode ensures that the schema change is reflected server-side. If 
you add or change a subscription to use an additional field, whether newly 
added or previously existent, you need to modify the Flexible Sync settings to 
enable querying against that field.

What's Next?
------------

- Read our :ref:`Kotlin SDK <kotlin-intro>` documentation.
- Find developer-oriented blog posts and integration tutorials on the 
  `MongoDB Developer Hub <https://developer.mongodb.com>`__.
- Join the `MongoDB Community forum <https://developer.mongodb.com/community/forums/c/realm/9>`__ 
  to learn from other MongoDB developers and technical experts.

.. include:: /includes/tutorial-request-for-feedback-note.rst
