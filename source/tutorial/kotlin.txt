.. _kotlin-tutorial:

============================
Android With Kotlin Tutorial
============================

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

Realm provides a Kotlin SDK that allows you to create an Android mobile
application with Kotlin using :android:`Jetpack Compose </jetpack/compose/documentation>`. 
This tutorial is based on the Kotlin Flexible Sync
Template App, named ``kotlin.todo.flex``, which illustrates the creation of a
To-do Item List management application. This application enables users to: 

- Register their email as a new user account.
- Sign in to their account with their email and password (and sign out later).
- Pause and restart device sync.
- View all users' items or only their to-do items.
- Create, modify, and delete their to-do items.

This tutorial adds functionality to the Template App. You will add a new ``Priority`` field 
to the existing ``Item`` model and update the 
:ref:`Flexible Sync subscription <queryable-fields>` to only show items within 
a range of priorities. 

Depending on your experience with Kotlin, this tutorial should take 
around 30 minutes.

.. note:: Check Out the Quick Start
   
   If you prefer to get started with your own application rather than follow a 
   guided tutorial, check out the :ref:`Kotlin Quick Start <kotlin-client-quick-start>`. 
   It includes copyable code examples and the essential information that you 
   need to set up an Atlas App Services backend.

Prerequisites
-------------

- :android:`Android Studio <studio/index.html>` Bumblebee 2021.1.1 or higher.
- JDK 11 or higher.
- Kotlin Plugin for Android Studio, version 1.6.10 or higher.
- An Android Virtual Device (AVD) using a supported CPU architecture.

.. include:: /includes/tutorial-template-prerequisite.rst 

Start with the Template
-----------------------
This tutorial is based on the Kotlin SDK Flexible Sync Template App named 
``kotlin.todo.flex``. We start with the default app and build new features 
on it. 

From Realm CLI, you can run the :ref:`realm-cli apps create 
<realm-cli-apps-create>` command to set up the backend and create the 
Kotlin base app. The following command creates a new app based on the 
kotlin.todo.flex template. With the options flags we can pass during creation,
the command below creates an app:

- Named "MyTutorialApp"
- Deployed in the US-VA region
- With the environment set to "development" (instead of production or QA)

.. code-block:: shell

   realm-cli apps create -n MyTutorialApp --template kotlin.todo.flex \
      --deployment-model global --location us-va --environment development

To learn more about the Template Apps and to install the Template App that this
tutorial uses in the Atlas App Services UI, see :ref:`template applications
<template-apps>`. 

Set up the Template App
-----------------------

.. procedure::

   .. step:: Open the App

      Navigate to the directory where the Realm CLI created the Template App. 
      The client code is in a ``frontend/kotlin.todo.flex`` directory.
      Open the ``build.gradle.kts`` in Android Studio.

   .. step:: Explore the App Structure

      Take a few minutes to explore the project organization while Android
      Studio indexes your project. Within the ``app/java/com.mongodb.app``
      directory, you can see a few files worth noting:

      .. cssclass:: config-table
      .. list-table::
         :header-rows: 1
         :widths: 35 65

         * - File
           - Purpose

         * - ComposeItemActivity.kt
           - Activity class that defines the layout and provides 
             functionality for opening a realm, writing Items to the realm, 
             logging a user out, and closing a realm.

         * - ComposeLoginActivity.kt
           - Activity class that defines the layout and provides 
             functionality for registering a user and logging a user in.

         * - TemplateApp.kt
           - Class that initializes the App Services App
           
      In this tutorial, you'll be working in the following files:

      .. cssclass:: config-table
      .. list-table::
         :header-rows: 1
         :widths: 35 65

         * - File
           - Purpose

         * - Item.kt
           - Located in the ``domain`` directory. Defines the Realm object we store in the database.

         * - SyncRepository.kt
           - Located in the ``data`` directory. Repository used to access Realm Sync.

         * - AddItem.kt
           - Located in the ``ui/tasks`` directory. Contains the composable function that 
             defines the Add Item alert dialog layout.

         * - AddItemViewModel.kt
           - Located in the ``presentation/tasks`` directory. The view model that contains 
             business logic and manages state when adding an item.

         * - Strings.xml
           - Located in the ``res/values`` directory. Defines the :android:`text string resources <guide/topics/resources/string-resource>`
             used in the app.  
       

   .. step:: Run the App

      Without making any changes to the code, you should be able to
      :android:`run the app <studio/run>`  
      on an Android Emulator using Android Studio or on a physical device.

      When you installed the template app, the Realm CLI also set up a new 
      backend for you and populated the ``realm.xml`` file with the correct app 
      ID. 

      Run the app, register a new user account, and then add a new Item to your 
      todo list.

   .. step:: Check the Backend

      Log in to `Atlas App Services <http://cloud.mongodb.com>`_. In the 
      :guilabel:`Atlas` tab, click on :guilabel:`Browse Collections`. In the list 
      of databases, find and expand the :guilabel:`todo` database, and then the 
      :guilabel:`Item` collection. You should see the document you created 
      in this collection.

Modify the Application
----------------------

.. procedure::

   .. step:: Add a New Property

      Now that you have confirmed everything is working as expected, we can add 
      changes. In this tutorial, we have decided that we want to add a
      "priority" property to each Item so that we can filter Items by their
      priority level. The priority property will be mapped to a PriorityLevel enum
      to constrain the possible values.
      
      To do this, follow these steps:

      A. Open the ``build.gradle.kts`` file in Android Studio. 

      #. Within the ``app/java/com.mongodb.app/domain`` folder open the ``Item`` class file.
            
      #. Add a PriorityLevel enum above the ``Item`` class:
         
         .. code-block:: kotlin

            enum class PriorityLevel() {
                  Severe, // priority 0
                  High,   // priority 1
                  Medium, // priority 2
                  Low     // priority 3
            }

      #. Add the following property to your Realm Object Schema, before the ``constructor``:

         .. code-block:: kotlin

            var priority: Int = PriorityLevel.Low.ordinal

         This sets the default priority to 3, indicating that it is a low-priority todo item.

   .. step:: Set the Priority when Creating a New Item

      A. Open the ``ui/tasks/AddItem.kt`` file. This file defines
         the composable functions for the UI that displays when a user clicks 
         the '+' button to add a new todo item. 
      
      #. Add the following imports: 
      
         .. code-block:: kotlin

            import androidx.compose.foundation.layout.fillMaxWidth
            import androidx.compose.foundation.layout.padding
            import androidx.compose.material3.*
            import androidx.compose.runtime.*
            import androidx.compose.ui.Modifier
            import androidx.compose.ui.unit.dp
            import com.mongodb.app.domain.PriorityLevel

      #. Now we can add the dropdown menu to the ``AddItemPrompt`` composable function. 
         Before the closing tag of the text ``Column``, add the following code 
         to the ``ColumnScope`` that will enable the user to pick a priority level 
         from a dropdown list.
   
         .. code-block:: xml

            val priorities = PriorityLevel.values()

            ExposedDropdownMenuBox(
               modifier = Modifier.padding(16.dp),
               expanded = viewModel.expanded.value,
               onExpandedChange = { viewModel.open() },
            ) {
               TextField(
                  readOnly = true,
                  value = viewModel.taskPriority.value.name,
                  onValueChange = {},
                  label = { Text(stringResource(R.string.item_priority)) },
                  trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = viewModel.expanded.value) },
                  colors = ExposedDropdownMenuDefaults.textFieldColors(),
                  modifier = Modifier
                        .fillMaxWidth()
                        .menuAnchor()
               )
               ExposedDropdownMenu(
                  expanded = viewModel.expanded.value,
                  onDismissRequest = { viewModel.close() }
               ) {
                  priorities.forEach {
                        DropdownMenuItem(
                           text = { Text(it.name) },
                           onClick = {
                              viewModel.updateTaskPriority(it)
                              viewModel.close()
                           }
                        )
                  }
               }
            }
               
      #. Next, we will define the dropdown field label as a string in the
         :android:`string resources file <guide/topics/resources/string-resource>`.
         Open the ``res/values/strings.xml`` file, and add the following before 
         the closing of the 'resource' element. 
   
         .. code-block:: xml

            <string name="item_priority">Item Priority</string>

      #. Now within the ``presentation/tasks`` folder, open the ``AddItemViewModel.kt``
         file. Here we will add the business logic related to our new dropdown menu.

         Add the following variables to the ``AddItemViewModel`` class: 

         .. code-block:: kotlin

            private val _taskPriority: MutableState<PriorityLevel> = mutableStateOf(PriorityLevel.Low)
            val taskPriority: State<PriorityLevel>
               get() = _taskPriority

            private val _expanded: MutableState<Boolean> = mutableStateOf(false)
            val expanded: State<Boolean>
               get() = _expanded

         Next, add the following related functions: 

         .. code-block:: kotlin

            fun updateTaskPriority(taskPriority: PriorityLevel) {
               _taskPriority.value = taskPriority
            }

            fun open() {
               _expanded.value = true
            }

            fun close() {
               _expanded.value = false
            }

         Now update the ``addTask()`` and ``cleanUpAndClose()`` functions to 
         include the new ``taskPriority`` parameter:

         .. code-block:: kotlin
            :emphasize-lines: 4, 7

            fun addTask() {
               CoroutineScope(Dispatchers.IO).launch {
                     runCatching {
                        repository.addTask(taskSummary.value, taskPriority.value)
                     }.onSuccess {
                        withContext(Dispatchers.Main) {
                           _addItemEvent.emit(AddItemEvent.Info("Task '$taskSummary' with priority $taskPriority added successfully."))
                        }
                     }.onFailure {
                        withContext(Dispatchers.Main) {
                           _addItemEvent.emit(AddItemEvent.Error("There was an error while adding the task '$taskSummary'", it))
                        }
                     }
                     cleanUpAndClose()
               }
            }

         .. code-block:: kotlin
            :emphasize-lines: 3

            private fun cleanUpAndClose() {
               _taskSummary.value = ""
               _taskPriority.value = PriorityLevel.Low
               _addItemPopupVisible.value = false
            }
      
      #. Finally, open the ``data/SyncRepository.kt`` file to reflect the same changes in the
         ``addTask()`` function. 

         Update the ``addTask()`` to pass the ``taskPriority`` as a parameter: 

         .. code-block:: kotlin

            suspend fun addTask(taskSummary: String, taskPriority: PriorityLevel)

         In the ``RealmSyncRepository`` class, update the ``addTask()`` function to pass 
         ``taskPriority`` as a parameter and write the ``priority`` field to the realm 
         as an integer (through the enum ordinal): 

         .. code-block:: kotlin
            :emphasize-lines: 1, 5

            override suspend fun addTask(taskSummary: String, taskPriority: PriorityLevel) {
               val task = Item().apply {
                     owner_id = currentUser.id
                     summary = taskSummary
                     priority = taskPriority.ordinal
               }
               realm.write {
                     copyToRealm(task)
               }
            }

         Last, in the ``MockRepository`` class, update the ``addTask()`` function to 
         reflect the same changes: 

         .. code-block:: kotlin
            
            override suspend fun addTask(taskSummary: String, taskPriority: PriorityLevel) = Unit

   .. step:: Run and Test
    
      At this point, you can rerun the application. Log in using the account 
      you created earlier in this tutorial. You will see the one Item you 
      previously created. Add a new Item, and you will see that you can now 
      set the priority. Choose ``High`` for the priority and save the Item. 

      Now switch back to the Atlas data page in your browser, and refresh the 
      ``Item`` collection. You should now see the new Item with the ``priority`` 
      field added and set to **1**. The existing Item does not have a ``priority`` 
      field.

      .. figure:: /images/swiftui-tutorial-two-new-items.png
         :alt:  Two items in a collection
         :figwidth: 300px

      .. note:: Why Didn't This Break Sync?
      
         Adding a property to a Realm object is not a breaking change and therefore 
         does not require a :ref:`client reset <client-resets>`. The template 
         app has Development Mode enabled, so changes to the client Realm object 
         are reflected in the server-side schema. For more information, see 
         :ref:`<development-mode>` and :ref:`<additive-changes-synced-schema>`.

Change the Subscription
~~~~~~~~~~~~~~~~~~~~~~~

.. procedure:: Change the Subscription

   .. step:: Update the subscription

      Within the ``app/java/com.mongodb.app/data`` folder, open the ``SyncRepository.kt``
      file, where we define the Flexible Sync subscription. The subscription defines
      which documents we sync with the user's device & account. Find the
      ``getQuery()`` function that our
      application calls on start. You can see that
      we are currently subscribing to two subscriptions: 
      
      - ``MINE``: All documents where the ``ownerId`` property matches the authenticated user.
      - ``ALL``: All documents from all users.
      
      We want to update the ``MINE`` subscription to *only* sync Items that are marked as High or Severe priority. 

      As you may recall, the ``priority`` field is of type ``int``, where the highest 
      priority ("Severe") has a value of 0, and the lowest priority ("Low") has 
      a value of 3. We can make direct comparisons between an integer and the 
      priority property. To do so, edit the RQL statement to include documents 
      where the priority is equal to or *less* than PriorityLevel.High (or 1), as 
      shown here:

      .. code-block:: kotlin
         :emphasize-lines: 3

         private fun getQuery(realm: Realm, subscriptionType: SubscriptionType): RealmQuery<Item> =
            when (subscriptionType) {
                  SubscriptionType.MINE -> realm.query("owner_id == $0 AND priority <= ${PriorityLevel.High.ordinal}", currentUser.id)
                  SubscriptionType.ALL -> realm.query()
            }

   .. step:: Run and Test
    
      Run the application again. Log in using the account you created earlier in
      this tutorial. Here, you'll notice an error if you check your
      :android:`logs using Logcat <studio/debug/am-logcat>`, you will see an
      entry that looks something like this:

      .. code-block:: sh
         :copyable: false
         
         io.realm.kotlin.mongodb.exceptions.BadFlexibleSyncQueryException:
         Client provided query with bad syntax: unsupported query for table
         "Item": key "priority" is not a queryable field

      This message tells us that we have added a field to our subscription
      without configuring Flexible Sync to use that field. 

   .. step:: Update Flexible Sync on the Server

      A. Switch back to the Atlas page in your browser. Select the 
         :guilabel:`Atlas App Services` tab and open the app you are using.

      #. In the left-hand navigation, choose :guilabel:`Device Sync`, and then 
         click **OK** in the dialog box about Development Mode being enabled.
      
      #. Scroll down to the :guilabel:`Select Queryable Fields` section. In the 
         dropdown labeled **Select or create a queryable field**, choose 
         "priority". The priority field will be added to the fields shown:

         .. figure:: /images/dotnet-tutorial-priority-subscribed.png
            :alt:  Priority field is now queryable.

      #. Save your changes.

   .. step:: Test the changes

      Return to your mobile app. To ensure the subscription is re-run, log out 
      the current user and then log in again. 
      After an initial moment when Realm re-syncs the document collection, you 
      will see the new Item of High priority that you created.
      
      If you want to test the functionality further, you can create Items of various 
      priorities. If you try to add an Item with a priority lower than High, you will 
      get a Toast message indicating you do not have permission. This is because the app
      will not allow you to add an item that does not meet the subscription rules.

      You'll note, too, that the document you initially created is not synced, 
      because it has a priority of ``null``. If you want this Item to be synced, 
      you can edit the document in the Atlas UI and add a value for the priority 
      field.

Conclusion
----------
Adding a property to an existing Realm object is a non-breaking change, and 
Development Mode ensures that the schema change is reflected server-side. If 
you add or change a subscription to use an additional field, whether newly 
added or previously existent, you need to modify the Flexible Sync settings to 
enable querying against that field.

What's Next?
------------

- Read our :ref:`Kotlin SDK <kotlin-intro>` documentation.
- Find developer-oriented blog posts and integration tutorials on the 
  `MongoDB Developer Hub <https://developer.mongodb.com>`__.
- Join the `MongoDB Community forum <https://developer.mongodb.com/community/forums/c/realm/9>`__ 
  to learn from other MongoDB developers and technical experts.

.. include:: /includes/tutorial-request-for-feedback-note.rst
